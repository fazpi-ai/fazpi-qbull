import Logger from './Logger.js';

/**
 * Converts a flat Redis array (e.g., ['key1', 'value1', 'key2', 'value2']) into an object.
 * @param {string[]} arr - The Redis array.
 * @returns {object} - The resulting object.
 */
function arrayToObject(arr) {
  const obj = {};
  for (let i = 0; i < arr.length; i += 2) {
    obj[arr[i]] = arr[i + 1];
  }
  return obj;
}

class QueueWorker {
  /**
   * Creates an instance of QueueWorker.
   * @param {object} redisClient - Redis client (compatible with ioredis) with stream methods.
   * @param {string} queueName - Name of the Redis stream (topic/queue) to listen to.
   * @param {function} jobHandler - Asynchronous function to process each job. Must accept (jobData, jobId).
   * @param {object} [options={}] - Configuration options.
   * @param {number} [options.concurrency=1] - Number of jobs to process in parallel.
   * @param {boolean} [options.processOrderedByKey=false] - Enable processing ordered by _orderingKey.
   * @param {string} [options.groupName] - Group name. Default is `group:${queueName}`.
   * @param {string} [options.consumerName] - Unique name for this consumer. Default is autogenerated.
   * @param {number} [options.blockTimeMs=5000] - Time in ms to block the reading of the stream.
   * @param {number} [options.gracefulShutdownTimeoutMs=30000] - Maximum time in ms to wait for active jobs to finish during shutdown.
   */
  constructor(redisClient, queueName, jobHandler, options = {}) {
    // Complete parameter validations
    if (!redisClient ||
      typeof redisClient.xgroup !== 'function' ||
      typeof redisClient.xreadgroup !== 'function' ||
      typeof redisClient.xack !== 'function') {
      throw new Error('QueueWorker requires a Redis client compatible with stream commands (xgroup, xreadgroup, xack).');
    }
    if (!queueName || typeof queueName !== 'string' || queueName.trim() === '') {
      throw new Error('queueName (non-empty string) is required.');
    }
    if (typeof jobHandler !== 'function') {
      throw new Error('jobHandler (function) is required.');
    }

    this.redisClient = redisClient;
    this.queueName = queueName.trim();
    this.jobHandler = jobHandler;

    this.options = {
      concurrency: 1,
      processOrderedByKey: false,
      blockTimeMs: 5000,
      groupName: `group:${this.queueName}`,
      consumerName: `consumer:${this.queueName}-${process.pid}-${Date.now()}`,
      gracefulShutdownTimeoutMs: 30000,
      ...options,
    };

    this.logger = new Logger(`QueueWorker:${this.options.consumerName}`);

    // Validate concurrency (now can use this.logger)
    if (typeof this.options.concurrency !== 'number' || this.options.concurrency < 1) {
      this.logger.warn(`Invalid concurrency value (${this.options.concurrency}). Using 1 by default.`);
      this.options.concurrency = 1;
    }

    this.isStopping = false;
    this.activeJobs = 0;
    this._pollTimeoutId = null;

    if (this.options.processOrderedByKey) {
      this.orderingKeyQueues = new Map();
      this.processingKeys = new Set();
      this.logger.info(`Ordered processing by key enabled for '${this.queueName}'.`);
    }

    this.logger.info(`QueueWorker initialized for '${this.queueName}'. Concurrency: ${this.options.concurrency}.`);
  }

  /**
   * Starts the worker: creates the consumer group and starts polling jobs.
   */
  async start() {
    if (this.isStopping) {
      this.logger.warn('Attempting to start a QueueWorker that is stopping or already stopped.');
      return;
    }
    this.logger.info(`Starting QueueWorker for queue '${this.queueName}', group '${this.options.groupName}'.`);
    this.isStopping = false;

    try {
      await this.redisClient.xgroup('CREATE', this.queueName, this.options.groupName, '$', 'MKSTREAM');
      this.logger.info(`Consumer group '${this.options.groupName}' ensured/created in stream '${this.queueName}'.`);
    } catch (err) {
      if (err.message && err.message.includes('BUSYGROUP')) {
        this.logger.info(`Consumer group '${this.options.groupName}' already exists in stream '${this.queueName}'.`);
      } else {
        this.logger.error(`Error creating/ensuring consumer group: ${err.message}`, err);
        throw err;
      }
    }
    this._doPoll();
  }

  _scheduleNextPoll(delayMs) {
    if (this.isStopping) return;
    if (this._pollTimeoutId) clearTimeout(this._pollTimeoutId);
    this._pollTimeoutId = setTimeout(() => this._doPoll(), delayMs);
  }

  async _doPoll() {
    if (this.isStopping) {
      this.logger.info('Polling stopped (isStopping).');
      return;
    }

    const slotsAvailableForFetch = this.options.concurrency - this.activeJobs;
    if (slotsAvailableForFetch <= 0 && !this.options.processOrderedByKey) {
      this.logger.debug(`All concurrency slots (${this.options.concurrency}) are occupied. Retrying polling in 1s.`);
      this._scheduleNextPoll(1000);
      return;
    }

    const fetchCount = this.options.processOrderedByKey ? this.options.concurrency : Math.max(1, slotsAvailableForFetch);

    try {
      this.logger.debug(`Polling stream '${this.queueName}' for up to ${fetchCount} jobs. Active: ${this.activeJobs}.`);
      const results = await this.redisClient.xreadgroup(
        'GROUP', this.options.groupName, this.options.consumerName,
        'COUNT', fetchCount,
        'BLOCK', this.options.blockTimeMs,
        'STREAMS', this.queueName, '>'
      );

      if (this.isStopping) {
        this.logger.info('Polling stopped (isStopping post-block).');
        return;
      }

      if (results && results.length > 0 && results[0] && results[0][1]) {
        const messages = results[0][1];
        this.logger.debug(`Received ${messages.length} messages from '${this.queueName}'.`);

        for (const message of messages) {
          if (!message || message.length < 2) { // Verify message structure
            this.logger.warn('Malformed message received, skipping.', message);
            continue;
          }
          const jobId = message[0];
          const jobDataArray = message[1];
          if (!Array.isArray(jobDataArray)) { // Verify that the job data is an array
            this.logger.warn(`Malformed job data for jobId ${jobId}, skipping.`, jobDataArray);
            continue;
          }
          const jobData = arrayToObject(jobDataArray);
          const orderingKey = jobData._orderingKey;

          if (this.options.processOrderedByKey && orderingKey) {
            if (!this.orderingKeyQueues.has(orderingKey)) {
              this.orderingKeyQueues.set(orderingKey, []);
            }
            this.orderingKeyQueues.get(orderingKey).push({ jobId, jobData });
            this.logger.debug(`Job ${jobId} (key: ${orderingKey}) enqueued internally.`);
          } else {
            if (this.activeJobs < this.options.concurrency) {
              this.activeJobs++;
              this._executeJob(jobId, jobData)
                .finally(() => {
                  this.activeJobs--;
                  if (this.options.processOrderedByKey) {
                    this._dispatchOrderedJobs();
                  }
                });
            } else {
              this.logger.warn(`Job ${jobId} (unordered) cannot be processed immediately, concurrency full. Will be retried by another consumer or in the next cycle.`);
              break;
            }
          }
        }
        if (this.options.processOrderedByKey) {
          this._dispatchOrderedJobs();
        }
      } else {
        this.logger.debug(`No messages received from '${this.queueName}' in this polling cycle.`);
      }
    } catch (err) {
      this.logger.error(`Error during xreadgroup for stream '${this.queueName}': ${err.message}`, err);
      this._scheduleNextPoll(5000);
      return;
    }

    this._scheduleNextPoll(0);
  }

  _dispatchOrderedJobs() {
    if (!this.options.processOrderedByKey || this.isStopping) {
      return;
    }

    for (const [key, queue] of this.orderingKeyQueues) {
      if (queue.length > 0 && !this.processingKeys.has(key) && this.activeJobs < this.options.concurrency) {
        this.processingKeys.add(key);
        this.activeJobs++;

        const { jobId, jobData } = queue.shift();
        if (queue.length === 0) {
          this.orderingKeyQueues.delete(key);
        }

        this.logger.debug(`Dispatching ordered job ${jobId} for key '${key}'. Remaining jobs for this key: ${queue.length}. Total active jobs: ${this.activeJobs}.`);

        this._executeJob(jobId, jobData, key)
          .finally(() => {
            this.activeJobs--;
            this.processingKeys.delete(key);
            this._dispatchOrderedJobs();
          });
      }
      if (this.activeJobs >= this.options.concurrency) break;
    }
  }

  async _executeJob(jobId, jobData, orderingKey = null) {
    const logPrefix = orderingKey ? `(Key: ${orderingKey}) ` : '';
    this.logger.info(`${logPrefix}Processing job ${jobId} from queue '${this.queueName}'.`);

    try {
      const result = await this.jobHandler(jobData, jobId);
      this.logger.info(`${logPrefix}Job ${jobId} completed. Result: ${result !== undefined ? JSON.stringify(result) : '[no result]'}`);

      try {
        await this.redisClient.xack(this.queueName, this.options.groupName, jobId);
        this.logger.info(`${logPrefix}Job ${jobId} confirmed (ACK).`);
      } catch (ackError) {
        this.logger.error(`${logPrefix}Error confirming (ACK) job ${jobId} after successful processing: ${ackError.message}`, ackError);
      }
    } catch (error) {
      this.logger.error(`${logPrefix}Error in jobHandler for job ${jobId}: ${error.message}`, { err: error, name: error.name, stack: error.stack });
    }
  }

  async stop() {
    this.logger.info(`Attempting to stop QueueWorker for queue '${this.queueName}'. ${this.activeJobs} active jobs.`);
    this.isStopping = true;
    if (this._pollTimeoutId) {
      clearTimeout(this._pollTimeoutId);
    }

    const stopTime = Date.now();
    const maxWaitMs = this.options.gracefulShutdownTimeoutMs;

    while (this.activeJobs > 0 && (Date.now() - stopTime) < maxWaitMs) {
      this.logger.debug(`Waiting for ${this.activeJobs} active jobs to finish... (Internal ordered queues: ${this.options.processOrderedByKey && this.orderingKeyQueues ? this.orderingKeyQueues.size : 0})`);
      await new Promise(resolve => setTimeout(resolve, 250));
    }

    if (this.activeJobs > 0) {
      this.logger.warn(`QueueWorker stopped, but ${this.activeJobs} jobs still active after the waiting period of ${maxWaitMs}ms.`);
    }

    if (this.options.processOrderedByKey && this.orderingKeyQueues) {
      let pendingInOrderedQueues = 0;
      this.orderingKeyQueues.forEach(q => pendingInOrderedQueues += q.length);
      if (pendingInOrderedQueues > 0) {
        this.logger.warn(`${pendingInOrderedQueues} jobs remained in internal ordered queues at the time of stopping the QueueWorker.`);
      }
    }
    this.logger.info('QueueWorker stopped completely.');
  }
}

export default QueueWorker;